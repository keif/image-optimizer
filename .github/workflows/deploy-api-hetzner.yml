name: Deploy Full Stack to Hetzner (Docker)

on:
  push:
    branches:
      - main
    paths:
      - 'api/**'
      - 'web/**'
      - 'docker-compose.prod.yml'
      - 'Caddyfile.prod'
      - '.github/workflows/deploy-api-hetzner.yml'
  workflow_dispatch:  # Allow manual trigger

env:
  DEPLOY_PATH: /opt/image-optimizer-docker
  DOCKER_COMPOSE_FILE: docker-compose.prod.yml

jobs:
  deploy:
    name: Deploy to Hetzner
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for git describe

      - name: Get version info
        id: version
        run: |
          echo "APP_VERSION=$(git describe --tags --always)" >> $GITHUB_OUTPUT
          echo "GIT_COMMIT=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
          echo "BUILD_TIME=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT

      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.HETZNER_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ secrets.HETZNER_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to Hetzner
        env:
          APP_VERSION: ${{ steps.version.outputs.APP_VERSION }}
          GIT_COMMIT: ${{ steps.version.outputs.GIT_COMMIT }}
          BUILD_TIME: ${{ steps.version.outputs.BUILD_TIME }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # SSH into server and execute deployment
          ssh -o StrictHostKeyChecking=no ${{ secrets.HETZNER_USER }}@${{ secrets.HETZNER_HOST }} "bash -s" << ENDSSH
          set -e

          # Set variables for deployment
          DEPLOY_PATH="/opt/image-optimizer-docker"
          DOCKER_COMPOSE_FILE="docker-compose.prod.yml"
          APP_VERSION="${{ steps.version.outputs.APP_VERSION }}"
          GIT_COMMIT="${{ steps.version.outputs.GIT_COMMIT }}"
          BUILD_TIME="${{ steps.version.outputs.BUILD_TIME }}"
          GITHUB_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          REPO_URL="https://x-access-token:\${GITHUB_TOKEN}@github.com/${{ github.repository }}.git"

          echo "üöÄ Starting deployment..."

          # Create deployment directory if it doesn't exist
          if [ ! -d "$DEPLOY_PATH" ]; then
            echo "Creating deployment directory: $DEPLOY_PATH"
            mkdir -p $DEPLOY_PATH
          fi

          # Migrate database if needed (before cloning)
          if [ ! -f "$DEPLOY_PATH/data/api_keys.db" ] && [ -f /opt/image-optimizer/data/api_keys.db ]; then
            echo "Migrating existing database..."
            mkdir -p $DEPLOY_PATH/data
            cp /opt/image-optimizer/data/api_keys.db $DEPLOY_PATH/data/
            chown -R $USER:$USER $DEPLOY_PATH/data
          fi

          # Clone or pull latest code
          if [ ! -d "$DEPLOY_PATH/.git" ]; then
            echo "Cloning repository..."
            # If directory is not empty, remove non-essential files first
            if [ "$(ls -A $DEPLOY_PATH 2>/dev/null | grep -v '^data$')" ]; then
              echo "Cleaning deployment directory (preserving data/)..."
              cd $DEPLOY_PATH
              find . -mindepth 1 -maxdepth 1 ! -name 'data' -exec rm -rf {} +
            fi
            git clone "\${REPO_URL}" $DEPLOY_PATH-tmp
            rsync -a $DEPLOY_PATH-tmp/ $DEPLOY_PATH/
            rm -rf $DEPLOY_PATH-tmp

            # Remove token from git config for security
            cd $DEPLOY_PATH
            git remote set-url origin https://github.com/${{ github.repository }}.git
          else
            echo "Pulling latest changes..."
            cd $DEPLOY_PATH
            # Update remote URL with token for this pull
            git remote set-url origin "\${REPO_URL}"
            git fetch origin
            git reset --hard origin/main
            # Remove token from git config for security
            git remote set-url origin https://github.com/${{ github.repository }}.git
          fi

          cd $DEPLOY_PATH

          # Export version info for docker-compose
          export APP_VERSION="${{ steps.version.outputs.APP_VERSION }}"
          export GIT_COMMIT="${{ steps.version.outputs.GIT_COMMIT }}"
          export BUILD_TIME="${{ steps.version.outputs.BUILD_TIME }}"

          echo "Building with version: $APP_VERSION"

          # Stop old systemd service if running (prevents port conflicts)
          if systemctl is-active --quiet image-optimizer; then
            echo "Stopping old systemd service..."
            systemctl stop image-optimizer
            systemctl disable image-optimizer
            echo "‚úì Old service stopped"
          fi

          # Ensure Caddy log directory exists
          if [ ! -d "/var/log/caddy" ]; then
            echo "Creating Caddy log directory..."
            mkdir -p /var/log/caddy
            chown -R caddy:caddy /var/log/caddy
            chmod 755 /var/log/caddy
            echo "‚úì Log directory created"
          fi

          # Update Caddyfile if it exists in repo
          if [ -f "Caddyfile.prod" ]; then
            echo "Updating Caddyfile..."
            cp Caddyfile.prod /etc/caddy/Caddyfile
            caddy validate --config /etc/caddy/Caddyfile
            # Reload Caddy in background to avoid SSH disconnection
            nohup systemctl reload caddy > /dev/null 2>&1 &
            sleep 2
            echo "‚úì Caddyfile updated and Caddy reload triggered"
          fi

          # Build and deploy with docker-compose
          echo "Building Docker images..."
          docker-compose -f $DOCKER_COMPOSE_FILE build --no-cache

          echo "Stopping old containers..."
          docker-compose -f $DOCKER_COMPOSE_FILE down || true

          echo "Deploying containers..."
          docker-compose -f $DOCKER_COMPOSE_FILE up -d

          # Wait for health checks (containers have 40s start_period)
          echo "Waiting for services to be healthy..."
          sleep 50

          # Check container status
          docker-compose -f $DOCKER_COMPOSE_FILE ps

          # Verify API is healthy
          if ! docker ps | grep -q "squish-api.*healthy"; then
            echo "‚ùå API container is not healthy!"
            docker logs squish-api --tail=50
            exit 1
          fi

          echo "‚úì API container is healthy"

          # Verify web is healthy or still starting (may need more time)
          if docker ps | grep -q "squish-web.*healthy"; then
            echo "‚úì Web container is healthy"
          elif docker ps | grep -q "squish-web.*starting"; then
            echo "‚è≥ Web container is starting (health check in progress)"
            echo "Waiting additional 30 seconds..."
            sleep 30
            if docker ps | grep -q "squish-web.*healthy"; then
              echo "‚úì Web container is now healthy"
            else
              echo "‚ö†Ô∏è  Web container status:"
              docker ps | grep squish-web
              docker logs squish-web --tail=20
              echo "Note: Container may still become healthy. Check manually if needed."
            fi
          else
            echo "‚ùå Web container is not healthy!"
            docker logs squish-web --tail=50
            exit 1
          fi

          echo "‚úì Deployment containers are running"

          # Cleanup old images
          echo "Cleaning up old Docker images..."
          docker image prune -f

          echo "‚úÖ Deployment complete!"
          ENDSSH

      - name: Verify deployment
        run: |
          echo "Verifying deployments..."
          sleep 5

          # Check API
          echo "Checking API..."
          API_RESPONSE=$(curl -s https://api.sosquishy.io/health || echo '{"status":"error"}')
          echo "API health: $API_RESPONSE"

          if echo "$API_RESPONSE" | grep -q '"status":"ok"'; then
            echo "‚úÖ API is healthy"
            API_VERSION=$(echo $API_RESPONSE | grep -o '"version":"[^"]*"' | cut -d'"' -f4)
            echo "  Version: $API_VERSION"
          else
            echo "‚ùå API health check failed!"
            exit 1
          fi

          # Check Frontend
          echo "Checking Frontend..."
          FRONTEND_STATUS=$(curl -s -o /dev/null -w "%{http_code}" https://sosquishy.io)
          echo "Frontend status code: $FRONTEND_STATUS"

          if [ "$FRONTEND_STATUS" = "200" ]; then
            echo "‚úÖ Frontend is serving correctly"
          else
            echo "‚ùå Frontend check failed (HTTP $FRONTEND_STATUS)"
            exit 1
          fi

          # Check ads.txt redirect
          echo "Checking ads.txt redirect..."
          ADS_REDIRECT=$(curl -s -o /dev/null -w "%{http_code}|%{redirect_url}" https://sosquishy.io/ads.txt)
          ADS_CODE=$(echo $ADS_REDIRECT | cut -d'|' -f1)
          ADS_URL=$(echo $ADS_REDIRECT | cut -d'|' -f2)

          if [ "$ADS_CODE" = "301" ]; then
            echo "‚úÖ ads.txt redirect working (301 ‚Üí $ADS_URL)"
          else
            echo "‚ö†Ô∏è  ads.txt redirect returned HTTP $ADS_CODE"
          fi

          echo ""
          echo "‚úÖ All deployments verified successfully!"

      - name: Notification
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "üéâ Deployment successful: ${{ steps.version.outputs.APP_VERSION }}"
          else
            echo "‚ùå Deployment failed"
          fi
